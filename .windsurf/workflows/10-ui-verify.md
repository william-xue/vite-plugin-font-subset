---
description: 前端 UI 页面验证（chrome-devtools 驱动）
---

> 适用场景：
> - 任何需要在浏览器里确认 UI / 字体 / 资源 / 报错情况的任务
> - 构建后或预览环境的「集成验证」、而不是单元测试
>
> 工具优先级：filesystem + run_command → chrome-devtools

## 0. 准备阶段（确认上下文）

1. **确认项目根目录**
   - 优先使用当前 IDE 工作区根目录。
   - 如有多项目/monorepo，向用户确认：
     - 「本次要验证的是哪个子项目？对应根目录是？」

2. **确认验证目标**（用简短问句收敛）
   - 示例提问：
     - 「这次主要想验证什么？字体是否生效 / 布局 / 报错 / 网络请求 / 交互？」
   - 将目标整理为清单：
     - 字体 / 资源
     - UI 布局
     - 控制台错误
     - 网络请求

---

## 1. 获取预览 URL

### 1.1 先问用户

1. 向用户发问：
   - 「当前是否已经有运行中的预览或 dev 服务器？如果有，请直接给我 URL。」
2. 分支处理：
   - **如果用户提供 URL**：
     - 直接进入「第 2 步：通过 chrome-devtools 打开页面」。
   - **如果用户没有 URL / 需要我起服务**：
     - 进入 1.2 步骤。

### 1.2 自行推断并启动预览服务

1. 读取目标项目的 `package.json`：
   - 优先查找脚本顺序：`preview` → `dev` → `start` → 其他（如 `serve`）。
   - 记录候选命令：
     - 如有 `preview`：`pnpm preview` / `npm run preview`（根据项目实际包管理器）。
     - 否则使用 `dev`：`pnpm dev` / `npm run dev`。

2. 向用户确认计划运行的命令（不要静默起服务）：
   - 例如：「我准备在 {cwd} 执行 `{pnpm preview}` 起预览服务，可以吗？」

3. 使用 `run_command` 启动服务（非阻塞）：
   - Cwd 设为项目根目录。
   - Blocking 设为 `false`，避免长期占用。
   - **SafeToAutoRun 一般保持 false**，交由用户确认。

4. 从命令输出中解析 URL：
   - 搜索类似：
     - `Local:   http://...`（Vite）
     - 或任意 `http://` / `https://` 地址。
   - 如果成功解析：
     - 使用该 URL 进入「第 2 步」。
   - 如果解析失败或服务起不来：
     - 向用户询问实际访问地址或请用户贴出终端输出。

---

## 2. 通过 chrome-devtools 打开页面

1. 使用 `chrome-devtools`：
   - 若还没有页面：调用 `new_page`，URL 设为上一步获得的预览地址。
   - 若已有页面：使用 `navigate_page` 切换到目标 URL。

2. 等待页面加载完成：
   - 可在需要时使用 `wait_for` 等待页面出现特征文本。

3. 采集基础信息：
   - 可以用 `take_snapshot` 或小脚本(`evaluate_script`)获取：
     - `document.title`
     - 视口尺寸（`window.innerWidth/innerHeight`）
     - 是否存在明显错误提示元素。

---

## 3. 通用验证清单

### 3.1 字体与资源验证（适用于字体子集、图标等）

1. 使用 `evaluate_script` 检查字体加载情况：
   - 读取 `document.fonts`：
     - family / status / weight / style
     - 关注目标字体是否有 `status: 'loaded'`。

2. 针对特定元素检查 `font-family`：
   - 通过选择器定位关键元素（如 `.custom-font`, `.title`, `body` 等）。
   - `getComputedStyle(el).fontFamily` / `fontWeight`，确认是否使用目标字体或子集字体。

3. 如需检查 Network：
   - 使用 `list_network_requests` / `get_network_request`：
     - 过滤字体请求（`.woff`, `.woff2`, `.ttf`, `.otf`）。
     - 记录：状态码 / 体积 / 缓存命中情况。

### 3.2 UI 布局与视觉验证

1. 使用 `take_screenshot`：
   - 视需求可以：
     - 截全页（`fullPage: true`）
     - 或针对某个元素（传入对应 `uid`）。

2. 根据需求检查：
   - 文字是否溢出 / 被截断。
   - 关键组件是否可见、未被遮挡。
   - 在不同视口宽度下（可使用 `resize_page`）布局是否正常。

### 3.3 错误与告警验证

1. 使用 `list_console_messages`：
   - 关注 `error` / `warn` 类型信息。
   - 如有与当前改动相关的报错，记录并在结果中高亮。

2. 根据用户关注点，补充特定检查：
   - 如表单交互、按钮点击等，可用 `click` / `fill` 模拟，并观察页面变化与控制台输出。

---

## 4. 输出报告模版

在回复用户时，使用类似结构化总结：

```markdown
[UI 验证报告] {页面/功能名称}

- **预览地址**：{url}
- **运行环境**：dev/preview/build 后预览
- **检查项**：字体 / 布局 / 错误 / 网络（勾选本次实际检查的）

### 1. 字体与资源
- **加载状态**：{某字体是否 loaded，字体文件请求是否 200}
- **应用位置**：{哪些元素实际使用了该字体}
- **潜在风险**：{如体积过大、无缓存、FOUT 风险}

### 2. UI 布局
- **视口尺寸**：{宽 x 高}
- **主要观察**：{关键模块的显示情况}

### 3. 错误与网络
- **控制台错误/警告**：{有无，与本次改动关系}
- **关键请求**：{接口/字体资源状态}

### 4. 结论与建议
- **总体结论**：通过 / 存在问题
- **建议动作**：下一步建议的修改或优化项
```

---

## 5. 使用提示

- 当用户主动提到「看一下页面效果 / 字体是否生效 / 检查首屏」时，可以主动建议使用本工作流。
- 如遇到：
  - 服务无法启动
  - 端口被占用
  - URL 无法访问
 先与用户确认实际运行方式和访问路径，再重试。

- 始终遵守「最小必要」原则：
  - 能用 snapshot + evaluate_script 解决的，不必频繁截图。
  - 只在与验证目标直接相关时使用 Network / Performance 相关工具。